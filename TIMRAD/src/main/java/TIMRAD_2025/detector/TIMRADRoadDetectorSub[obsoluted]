package TIMRAD_2025.module.complex.self;

import adf.core.agent.communication.MessageManager;
import adf.core.agent.communication.standard.bundle.MessageUtil;
import adf.core.agent.communication.standard.bundle.centralized.CommandAmbulance;
import adf.core.agent.communication.standard.bundle.centralized.CommandFire;
import adf.core.agent.communication.standard.bundle.centralized.CommandPolice;
import adf.core.agent.communication.standard.bundle.information.MessageAmbulanceTeam;
import adf.core.agent.communication.standard.bundle.information.MessageBuilding;
import adf.core.agent.communication.standard.bundle.information.MessageCivilian;
import adf.core.agent.communication.standard.bundle.information.MessageFireBrigade;
import adf.core.agent.communication.standard.bundle.information.MessagePoliceForce;
import adf.core.agent.communication.standard.bundle.information.MessageRoad;
import adf.core.agent.develop.DevelopData;
import adf.core.agent.info.AgentInfo;
import adf.core.agent.info.ScenarioInfo;
import adf.core.agent.info.WorldInfo;
import adf.core.agent.module.ModuleManager;
import adf.core.agent.precompute.PrecomputeData;
import adf.core.component.communication.CommunicationMessage;
import adf.core.component.module.algorithm.Clustering;
import adf.core.component.module.algorithm.PathPlanning;
import adf.core.component.module.complex.RoadDetector;
import rescuecore2.config.Config;
import rescuecore2.standard.entities.*;
import rescuecore2.standard.entities.StandardEntityConstants.Fieryness;
import rescuecore2.standard.kernel.comms.ChannelCommunicationModel;
import rescuecore2.worldmodel.EntityID;

import java.awt.Polygon;
import java.awt.Shape;
import java.util.*;
import java.util.stream.Collectors;

import org.hamcrest.core.Is;

import static rescuecore2.standard.entities.StandardEntityURN.*;

public class TIMRADRoadDetectorSub extends RoadDetector {
	private Set<EntityID> targetAreas;
	private Set<EntityID> priorityRoads;

	private PathPlanning pathPlanning;

	private int clearDistance; //「瓦礫」を除去する範囲

	private EntityID result;

	public TIMRADRoadDetectorSub(AgentInfo ai, WorldInfo wi, ScenarioInfo si, ModuleManager moduleManager, DevelopData developData) {
		super(ai, wi, si, moduleManager, developData);

		this.clearDistance = si.getClearRepairDistance();

		switch (scenarioInfo.getMode()) {
		case PRECOMPUTATION_PHASE:
			this.pathPlanning = moduleManager.getModule("SampleRoadDetector.PathPlanning", "adf.core.component.module.algorithm.PathPlanning");
			break;
		case PRECOMPUTED:
			this.pathPlanning = moduleManager.getModule("SampleRoadDetector.PathPlanning", "adf.core.component.module.algorithm.PathPlanning");
			break;
		case NON_PRECOMPUTE:
			this.pathPlanning = moduleManager.getModule("SampleRoadDetector.PathPlanning", "adf.core.component.module.algorithm.PathPlanning");
			break;
		}
		registerModule(this.pathPlanning);
		this.result = null;
	}

	@Override
	public RoadDetector calc() {
		if (this.result == null) {
			EntityID positionID = this.agentInfo.getPosition();
			if (this.targetAreas.contains(positionID)) {
				this.result = positionID;
				return this;
			}

			this.result = this.getEntrance(positionID); //「建物」の入口を塞いでいる「瓦礫」を取得
			if (this.result != null) {
				return this;
			}
			this.result = this.getArroundFire(positionID); //燃えている「建物」の周囲の「瓦礫」を取得
			if (this.result != null) {
				return this;
			}
			this.result = this.getGroup(positionID); //大勢の「人」がいる道を塞いでいる「瓦礫」を取得
			if (this.result != null) {
				return this;
			}

			List<EntityID> removeList = new ArrayList<>(this.priorityRoads.size());
			for (EntityID id : this.priorityRoads) {
				if (!this.targetAreas.contains(id)) {
					removeList.add(id);
				}
			}
			this.priorityRoads.removeAll(removeList);
			if (this.priorityRoads.size() > 0) {
				this.pathPlanning.setFrom(positionID);
				this.pathPlanning.setDestination(this.targetAreas);
				List<EntityID> path = this.pathPlanning.calc().getResult();
				if (path != null && path.size() > 0) {
					this.result = path.get(path.size() - 1);
				}
				return this;
			}


			this.pathPlanning.setFrom(positionID);
			this.pathPlanning.setDestination(this.targetAreas);
			List<EntityID> path = this.pathPlanning.calc().getResult();
			if (path != null && path.size() > 0) {
				this.result = path.get(path.size() - 1);
			}
		}
		return this;
	}

	//最も近いターゲットへの経路を取得
	private EntityID getPathToNearestTarget(EntityID positionID, ArrayList<EntityID> targets) {

		EntityID nearestTarget = null;

		for (EntityID target : targets) {
			if (nearestTarget == null) //ループ一周目
			{
				nearestTarget = target;
			} else if (this.worldInfo.getDistance(positionID, target) <
					this.worldInfo.getDistance(positionID, nearestTarget)) //現在地から暫定で最も近い場合
			{
				nearestTarget = target; //更新
			}
		}

		this.pathPlanning.setFrom(positionID);
		this.pathPlanning.setDestination(nearestTarget);
		List<EntityID> path = this.pathPlanning.calc().getResult();
		if (path != null && path.size() > 0) {
			return path.get(path.size() - 1);
		}

		return null;
	}

	private EntityID getEntrance(EntityID positionID) {
		ArrayList<EntityID> buildings = new ArrayList<>(this.worldInfo.getEntityIDsOfType(StandardEntityURN.BUILDING)); //全ての「建物」

		ArrayList<EntityID> blockadedEntrances = new ArrayList<>(); //全ての「瓦礫で塞がれている建物の入口」
		ArrayList<EntityID> priorityEntrances = new ArrayList<>(); //優先すべき全ての「瓦礫で塞がれている建物の入口」

		for (EntityID building : buildings) {
			StandardEntity areaEntity = worldInfo.getEntity(building);
			if (!(areaEntity instanceof Area)) {
				continue;
			}

			Area area = (Area) areaEntity;

			List<EntityID> neighbours = area.getNeighbours(); //「建物」に隣接する全ての「エリア」
			if (neighbours != null && neighbours.size() > 0) //「建物に隣接するエリア」がある場合
			{
				for (EntityID neighbour : neighbours) {
					if (this.worldInfo.getEntity(neighbour) instanceof Road) //「建物に隣接するエリア」が「道」の場合
					{
						StandardEntity entranceEntity = this.worldInfo.getEntity(neighbour);
						if (!(entranceEntity instanceof Road)) {
							continue;
						}
						Road entrance = (Road) entranceEntity;
						if (entrance.isBlockadesDefined() &&
								entrance.getBlockades().size() > 0) //「建物の入口」が「瓦礫」で塞がれている場合
						{
							if (this.worldInfo.getEntity(building) instanceof Refuge &&
									this.worldInfo.getNumberOfBuried(building) > 1) //「建物」が「避難所」または複数の「人」が埋まっている場合
							{
								priorityEntrances.add(entrance.getID());
							} else if (this.worldInfo.getNumberOfBuried(building) == 1) //1人だけ「人」が埋まっている場合
							{
								blockadedEntrances.add(entrance.getID());
							}
						}
					}
				}
			}
		}

		EntityID target = null;

		if (!priorityEntrances.isEmpty()) {
			target = this.getPathToNearestTarget(positionID, priorityEntrances);
			if (target != null) {
				return target;
			}
		}
		if (!blockadedEntrances.isEmpty()) {
			target = this.getPathToNearestTarget(positionID, blockadedEntrances);
			if (target != null) {
				return target;
			}
		}
		//my
		/*

ArrayList<EntityID>roadList = new ArrayList<EntityID>(this.worldInfo.getEntityIDsOfType(StandardEntityURN.ROAD));
ArrayList<EntityID>blockedRoad = new ArrayList<EntityID>();
Human human = (Human)this.agentInfo.me();

for(EntityID entityRoad : roadList) {
Road roadEntityRoad = (Road)this.worldInfo.getEntity(entityRoad);
if(roadEntityRoad.isBlockadesDefined() && roadEntityRoad.getBlockades().size() > 0){
blockedRoad.add(roadEntityRoad.getID());
}
}

for(EntityID entityBlockRoad : blockedRoad) {
Road roadEntityBlockRoad = (Road)this.worldInfo.getEntity(entityBlockRoad);
int targetDistance = this.worldInfo.getDistance(human,roadEntityBlockRoad);
// EntityID IDBlockRoad = (EntityID)roadEntityBlockRoad;

if(targetDistance < clearDistance/2) {
target = this.getPathToNearestTarget(positionID, blockedRoad);
if(target != null) {
return target;
}
}
}
		 */
		//end
		//        int targetDistance;

		// ArrayList<EntityID>roadLists = new ArrayList<EntityID>(this.worldInfo.getEntityIDsOfType(StandardEntityURN.ROAD));

		return null;
	}

	private EntityID getArroundFire(EntityID positionID) {
		ArrayList<EntityID> buildings = new ArrayList<>(this.worldInfo.getEntityIDsOfType(StandardEntityURN.BUILDING)); //全ての「建物」
		ArrayList<EntityID> roads = new ArrayList<>(this.worldInfo.getEntityIDsOfType(StandardEntityURN.ROAD)); //全ての「道」

		ArrayList<EntityID> targets = new ArrayList<>();
		for (EntityID buildingEntity : buildings) {
			Building building = (Building) this.worldInfo.getEntity(buildingEntity);

			if (building != null &&
					building.isOnFire() &&
					building.isFierynessDefined() &&
					building.getFieryness() > 0) //「建物」が燃えている場合
			{
				for (EntityID road : roads) {
					if (((Road) this.worldInfo.getEntity(road)).isBlockadesDefined() && ((Road) this.worldInfo.getEntity(road)).getBlockades().size() > 0 &&
							this.worldInfo.getDistance(buildingEntity, road) <= this.scenarioInfo.getFireExtinguishMaxDistance()) //「道」が「瓦礫」で塞がれており、「建物」から近い場合
					{
						targets.add(road);
					}
				}
			}
		}

		EntityID target = null;

		if (!targets.isEmpty()) //「燃えている建物の周囲の瓦礫で塞がれている道」が存在する場合
		{
			target = this.getPathToNearestTarget(positionID, targets);
			if (target != null) {
				return target;
			}
		}

		return null;
	}

	private EntityID getGroup(EntityID positionID) {
		ArrayList<EntityID> roads = new ArrayList<>(this.worldInfo.getEntityIDsOfType(StandardEntityURN.ROAD)); //全ての「道」
		ArrayList<EntityID> civilians = new ArrayList<>(this.worldInfo.getEntityIDsOfType(StandardEntityURN.CIVILIAN)); //全ての「市民」
		ArrayList<EntityID> freeAmbulanceTeams = new ArrayList<>(this.worldInfo.getEntityIDsOfType(StandardEntityURN.AMBULANCE_TEAM)); //全ての「市民を背負っていないAT」
		ArrayList<EntityID> loadingAmbulanceTeams = new ArrayList<>(); //全ての「市民を背負っているAT」
		ArrayList<EntityID> fireBrigades = new ArrayList<>(this.worldInfo.getEntityIDsOfType(StandardEntityURN.FIRE_BRIGADE)); //全ての「FB」
		//ArrayList<EntityID> policeForces = new ArrayList<>(this.worldInfo.getEntityIDsOfType(StandardEntityURN.POLICE_FORCE)); //全ての「PF」

		//「AT」が「市民」を背負っているかどうかの判定
		List<EntityID> removeList = new ArrayList<>();
		for (EntityID ambulanceTeam : freeAmbulanceTeams) {
			for (EntityID civilian : civilians) {
				if (worldInfo.getDistance(ambulanceTeam, civilian) == 0) //「AT」と「市民」の距離が0の場合
				{
					loadingAmbulanceTeams.add(ambulanceTeam);
					removeList.add(ambulanceTeam);
					break;
				}
			}
		}
		freeAmbulanceTeams.removeAll(removeList);

		ArrayList<EntityID> targets = new ArrayList<>(); //全ての「大勢のの人がいる道を塞いでいる瓦礫」

		int humanWeight;
		int agentWeight; //「瓦礫付近のFBとAT」の数

		int border; //基準点（視界内の「人」の数）

		for (EntityID roadID : roads) {
			StandardEntity roadEntity = worldInfo.getEntity(roadID);
			if (!(roadEntity instanceof Road)) {
				continue;
			}

			Road road = (Road) roadEntity;

			if (road.isBlockadesDefined() && road.getBlockades().size() > 0) //「道」が「瓦礫」で塞がれている場合
			{
				border = 0;

				for (EntityID entityInSight : this.worldInfo.getChanged().getChangedEntities()) //視界内の「人」を数える
				{
					if (this.worldInfo.getEntity(entityInSight) instanceof Human) {
						border += 1;
					}
				}

				humanWeight = 0;
				agentWeight = 0;

				for (EntityID civilian : civilians) {
					if (this.worldInfo.getDistance(roadID, civilian) <= this.clearDistance) //「瓦礫」付近の「市民」を数える
					{
						humanWeight += 1;
					}
				}
				for (EntityID ambulanceTeam : freeAmbulanceTeams) {
					if (this.worldInfo.getDistance(roadID, ambulanceTeam) <= this.clearDistance) //「瓦礫」付近の「市民を背負っていないAT」を数える
					{
						agentWeight += 1;
					}
				}
				for (EntityID ambulanceTeam : loadingAmbulanceTeams) {
					if (this.worldInfo.getDistance(roadID, ambulanceTeam) <= this.clearDistance) //「瓦礫」付近の「市民を背負っているAT」を数える
					{
						agentWeight += 1;
					}
				}
				for (EntityID fireBrigade : fireBrigades) {
					if (this.worldInfo.getDistance(roadID, fireBrigade) <= this.clearDistance) //「瓦礫」付近の「FB」を数える
					{
						agentWeight += 1;
					}
				}/*
for(EntityID policeForce : policeForces)
{
if(this.worldInfo.getDistance(road, policeForce) <= this.clearDistance) //「瓦礫」付近の「PF」を数える
{
agentWeight += 0;
}
}*/
				humanWeight += agentWeight * agentWeight;

				if (humanWeight >= border / 2 + 1) //「瓦礫」付近に「人」が大勢いる（全ての「視界内の人」の半数以上が「瓦礫」付近にいる）場合
				{
					targets.add(roadID);
				}
			}
		}

		EntityID target = null;
		if (!targets.isEmpty()) //「大勢のの人がいる道を塞いでいる瓦礫」が存在する場合
		{
			target = this.getPathToNearestTarget(positionID, targets);
		}

		return target;
	}

	@Override
	public EntityID getTarget() {
		return this.result;
	}

	@Override
	public RoadDetector precompute(PrecomputeData precomputeData) {
		super.precompute(precomputeData);
		if (this.getCountPrecompute() >= 2) {
			return this;
		}
		return this;
	}

	@Override
	public RoadDetector resume(PrecomputeData precomputeData) {
		super.resume(precomputeData);
		if (this.getCountResume() >= 2) {
			return this;
		}
		this.targetAreas = new HashSet<>();
		for (StandardEntity e : this.worldInfo.getEntitiesOfType(REFUGE, BUILDING, GAS_STATION)) {
			for (EntityID id : ((Building) e).getNeighbours()) {
				StandardEntity neighbour = this.worldInfo.getEntity(id);
				if (neighbour instanceof Road) {
					this.targetAreas.add(id);
				}
			}
		}
		this.priorityRoads = new HashSet<>();
		for (StandardEntity e : this.worldInfo.getEntitiesOfType(REFUGE)) {
			for (EntityID id : ((Building) e).getNeighbours()) {
				StandardEntity neighbour = this.worldInfo.getEntity(id);
				if (neighbour instanceof Road) {
					this.priorityRoads.add(id);
				}
			}
		}
		return this;
	}

	@Override
	public RoadDetector preparate() {
		super.preparate();
		if (this.getCountPreparate() >= 2) {
			return this;
		}
		this.targetAreas = new HashSet<>();
		for (StandardEntity e : this.worldInfo.getEntitiesOfType(REFUGE, BUILDING, GAS_STATION)) {
			for (EntityID id : ((Building) e).getNeighbours()) {
				StandardEntity neighbour = this.worldInfo.getEntity(id);
				if (neighbour instanceof Road) {
					this.targetAreas.add(id);
				}
			}
		}
		this.priorityRoads = new HashSet<>();
		for (StandardEntity e : this.worldInfo.getEntitiesOfType(REFUGE)) {
			for (EntityID id : ((Building) e).getNeighbours()) {
				StandardEntity neighbour = this.worldInfo.getEntity(id);
				if (neighbour instanceof Road) {
					this.priorityRoads.add(id);
				}
			}
		}
		return this;
	}

	@Override
	public RoadDetector updateInfo(MessageManager messageManager) {
		super.updateInfo(messageManager);
		if (this.getCountUpdateInfo() >= 2) {
			return this;
		}
		if (this.result != null) {
			if (this.agentInfo.getPosition().equals(this.result)) {
				StandardEntity entity = this.worldInfo.getEntity(this.result);
				if (entity instanceof Building) {
					this.result = null;
				} else if (entity instanceof Road) {
					Road road = (Road) entity;
					if (!road.isBlockadesDefined() || road.getBlockades().isEmpty()) {
						this.targetAreas.remove(this.result);
						this.result = null;
					}
				}
			}
		}
		Set<EntityID> changedEntities = this.worldInfo.getChanged().getChangedEntities();
		for (CommunicationMessage message : messageManager.getReceivedMessageList()) {
			Class<? extends CommunicationMessage> messageClass = message.getClass();
			if (messageClass == MessageAmbulanceTeam.class) {
				this.reflectMessage((MessageAmbulanceTeam) message);
			} else if (messageClass == MessageFireBrigade.class) {
				this.reflectMessage((MessageFireBrigade) message);
			} else if (messageClass == MessageRoad.class) {
				this.reflectMessage((MessageRoad) message, changedEntities);
			} else if (messageClass == MessagePoliceForce.class) {
				this.reflectMessage((MessagePoliceForce) message);
			} else if (messageClass == CommandPolice.class) {
				this.reflectMessage((CommandPolice) message);
			}
		}
		for (EntityID id : this.worldInfo.getChanged().getChangedEntities()) {
			StandardEntity entity = this.worldInfo.getEntity(id);
			if (entity instanceof Road) {
				Road road = (Road) entity;
				if (!road.isBlockadesDefined() || road.getBlockades().isEmpty()) {
					this.targetAreas.remove(id);
				}
			}
		}
		return this;
	}

	private void reflectMessage(MessageRoad messageRoad, Collection<EntityID> changedEntities) {
		if (messageRoad.isBlockadeDefined() && !changedEntities.contains(messageRoad.getBlockadeID())) {
			MessageUtil.reflectMessage(this.worldInfo, messageRoad);
		}
		if (messageRoad.isPassable()) {
			this.targetAreas.remove(messageRoad.getRoadID());
		}
	}

	private void reflectMessage(MessageAmbulanceTeam messageAmbulanceTeam) {
		if (messageAmbulanceTeam.getPosition() == null) {
			return;
		}
		if (messageAmbulanceTeam.getAction() == MessageAmbulanceTeam.ACTION_RESCUE) {
			StandardEntity position = this.worldInfo.getEntity(messageAmbulanceTeam.getPosition());
			if (position != null && position instanceof Building) {
				this.targetAreas.removeAll(((Building) position).getNeighbours());
			}
		} else if (messageAmbulanceTeam.getAction() == MessageAmbulanceTeam.ACTION_LOAD) {
			StandardEntity position = this.worldInfo.getEntity(messageAmbulanceTeam.getPosition());
			if (position != null && position instanceof Building) {
				this.targetAreas.removeAll(((Building) position).getNeighbours());
			}
		} else if (messageAmbulanceTeam.getAction() == MessageAmbulanceTeam.ACTION_MOVE) {
			if (messageAmbulanceTeam.getTargetID() == null) {
				return;
			}
			StandardEntity target = this.worldInfo.getEntity(messageAmbulanceTeam.getTargetID());
			if (target instanceof Building) {
				for (EntityID id : ((Building) target).getNeighbours()) {
					StandardEntity neighbour = this.worldInfo.getEntity(id);
					if (neighbour instanceof Road) {
						this.priorityRoads.add(id);
					}
				}
			} else if (target instanceof Human) {
				Human human = (Human) target;
				if (human.isPositionDefined()) {
					StandardEntity position = this.worldInfo.getPosition(human);
					if (position instanceof Building) {
						for (EntityID id : ((Building) position).getNeighbours()) {
							StandardEntity neighbour = this.worldInfo.getEntity(id);
							if (neighbour instanceof Road) {
								this.priorityRoads.add(id);
							}
						}
					}
				}
			}
		}
	}

	private void reflectMessage(MessageFireBrigade messageFireBrigade) {
		if (messageFireBrigade.getTargetID() == null) {
			return;
		}
		if (messageFireBrigade.getAction() == MessageFireBrigade.ACTION_REFILL) {
			StandardEntity target = this.worldInfo.getEntity(messageFireBrigade.getTargetID());
			if (target instanceof Building) {
				for (EntityID id : ((Building) target).getNeighbours()) {
					StandardEntity neighbour = this.worldInfo.getEntity(id);
					if (neighbour instanceof Road) {
						this.priorityRoads.add(id);
					}
				}
			} else if (target.getStandardURN() == HYDRANT) {
				this.priorityRoads.add(target.getID());
				this.targetAreas.add(target.getID());
			}
		}
	}

	private void reflectMessage(MessagePoliceForce messagePoliceForce) {
		if (messagePoliceForce.getAction() == MessagePoliceForce.ACTION_CLEAR) {
			if (messagePoliceForce.getAgentID().getValue() != this.agentInfo.getID().getValue()) {
				if (messagePoliceForce.isTargetDefined()) {
					EntityID targetID = messagePoliceForce.getTargetID();
					if (targetID == null) {
						return;
					}
					StandardEntity entity = this.worldInfo.getEntity(targetID);
					if (entity == null) {
						return;
					}

					if (entity instanceof Area) {
						this.targetAreas.remove(targetID);
						if (this.result != null && this.result.getValue() == targetID.getValue()) {
							if (this.agentInfo.getID().getValue() < messagePoliceForce.getAgentID().getValue()) {
								this.result = null;
							}
						}
					} else if (entity.getStandardURN() == BLOCKADE) {
						EntityID position = ((Blockade) entity).getPosition();
						this.targetAreas.remove(position);
						if (this.result != null && this.result.getValue() == position.getValue()) {
							if (this.agentInfo.getID().getValue() < messagePoliceForce.getAgentID().getValue()) {
								this.result = null;
							}
						}
					}

				}
			}
		}
	}

	private void reflectMessage(CommandPolice commandPolice) {
		boolean flag = false;
		if (commandPolice.isToIDDefined() && this.agentInfo.getID().getValue() == commandPolice.getToID().getValue()) {
			flag = true;
		} else if (commandPolice.isBroadcast()) {
			flag = true;
		}
		if (flag && commandPolice.getAction() == CommandPolice.ACTION_CLEAR) {
			if (commandPolice.getTargetID() == null) {
				return;
			}
			StandardEntity target = this.worldInfo.getEntity(commandPolice.getTargetID());
			if (target instanceof Area) {
				this.priorityRoads.add(target.getID());
				this.targetAreas.add(target.getID());
			} else if (target.getStandardURN() == BLOCKADE) {
				Blockade blockade = (Blockade) target;
				if (blockade.isPositionDefined()) {
					this.priorityRoads.add(blockade.getPosition());
					this.targetAreas.add(blockade.getPosition());
				}
			}
		}
	}
}